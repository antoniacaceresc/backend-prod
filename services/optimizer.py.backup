# services/optimizer.py
import uuid
import math
import os
import time
from typing import List, Dict, Any, Optional, Iterable, Tuple

import pandas as pd
from ortools.sat.python import cp_model

from services.file_processor import read_file, process_dataframe
from services.math_utils import format_dates
from config import get_client_config
from concurrent.futures import ThreadPoolExecutor, as_completed
from services.models import Pedido, EstadoOptimizacion, TipoCamion, TruckCapacity
from services.config_helpers import extract_truck_capacities
from services.models import (
    Pedido, Camion, EstadoOptimizacion, TruckCapacity, 
    TipoRuta, TipoCamion, ConfiguracionGrupo, StatusOptimizacion
)
from services.config_helpers import extract_truck_capacities, get_capacity_for_type
from services.solver_helpers import (
    preparar_datos_solver,
    reconstruir_camion_desde_solver,
    calcular_posiciones_apilabilidad,
    filtrar_pedidos_validos,
    agrupar_pedidos_por_criterio,
    heuristica_ffd_pedidos
)
from services.constants import SCALE_VCU, SCALE_PALLETS, PESO_VCU, PESO_CAMIONES, PESO_PEDIDOS

# ---------------------------------------------------------
# Constantes (capping)
# ---------------------------------------------------------
MAX_CAMIONES_CP_SAT = int(os.getenv("MAX_CAMIONES_CP_SAT", "20"))
MAX_TIEMPO_POR_GRUPO = int(os.getenv("MAX_TIEMPO_POR_GRUPO", "30"))
SCALE = 1000  # para VCU
GROUP_MAX_WORKERS = max((os.cpu_count() or 4) - 1, 1)
GROUP_MAX_WORKERS = int(os.getenv("GROUP_MAX_WORKERS", str(GROUP_MAX_WORKERS)))
THREAD_WORKERS_NORMAL = int(os.getenv("THREAD_WORKERS_NORMAL", str(min(8, (os.cpu_count() or 4)))))



# ---------------------------------------------------------
# Orquestación multi-modo
# ---------------------------------------------------------

def _build_normal_groups_disjoint(df: pd.DataFrame, rutas: list, mix_grupos: list, usa_oc: bool) -> list:
    """Particiona *exclusivamente* los pedidos en grupos disjuntos para rutas 'normal'.
    Mantiene el mismo orden de `generar_rutas` para compatibilidad de negocio.
    """
    grupos = []  # [(cfg, df_grp)]
    asignado = pd.Series(False, index=df.index)
    for cds, ces, oc in generar_rutas("normal", rutas, df, mix_grupos, usa_oc):
        mask = df["CD"].isin(cds) & df["CE"].isin(ces)
        if oc is not None:
            if isinstance(oc, list):
                mask &= df["OC"].isin(oc)
            else:
                mask &= df["OC"].eq(oc)
        mask &= ~asignado
        sub = df[mask]
        if sub.empty:
            continue
        cfg = {"id": f"normal__{'-'.join(cds)}__{'-'.join(map(str, ces))}" + (f"__{oc}" if oc else ""),
               "tipo": "normal", "ce": ces, "cd": cds, "oc": oc}
        grupos.append((cfg, sub.copy()))
        asignado.loc[sub.index] = True
    return grupos

def run_optimizacion(df: pd.DataFrame, raw_pedidos: List[Dict[str, Any]], config, modo: str, tpg: int, timeout: int) -> Dict[str, Any]:
    """Ejecuta optimización por fases según `modo` y postprocesa camiones."""
    res = ejecutar_optimizacion(df.copy(), raw_pedidos, config, modo, tpg, timeout)
    res["camiones"] = postprocesar_camiones(res.get("camiones", []), config)
    return res


# services/optimizer.py

def optimizar_con_dos_fases(
    raw_df: pd.DataFrame, 
    client_config, 
    cliente: str, 
    venta: str, 
    request_timeout: int, 
    max_tpg: int
) -> Dict[str, Any]:
    """
    Función principal de optimización con dos fases (VCU y BinPacking).
    
    OPTIMIZADO: Sin conversiones temporales, trabaja 100% con objetos.
    
    Args:
        raw_df: DataFrame raw del Excel
        client_config: Configuración del cliente
        cliente: Nombre del cliente
        venta: Tipo de venta ("Secos", "Purina", etc.)
        request_timeout: Timeout total en segundos
        max_tpg: Tiempo máximo por grupo
    
    Returns:
        Dict con resultados de ambas fases
    """
    t_total = time.time()
    
    # 1) Preprocesamiento: DataFrame → List[Pedido] (conversión única)
    t1 = time.time()
    pedidos: List[Pedido] = process_dataframe(raw_df, client_config, cliente, venta)
    print(f"[TIMING] 1. DataFrame → Pedidos: {time.time() - t1:.3f}s")
    
    if not pedidos:
        return {
            "error": {
                "message": "No hay pedidos válidos para optimizar",
                "traceback": ""
            }
        }
    
    # 2) Extraer capacidades de camiones
    t2 = time.time()
    capacidades = extract_truck_capacities(client_config)
    capacidad_normal = capacidades[TipoCamion.NORMAL]
    capacidad_bh = capacidades.get(TipoCamion.BH)
    print(f"[TIMING] 2. Extraer capacidades: {time.time() - t2:.3f}s")
    
    # 3) Calcular tiempo por grupo (SIN conversión temporal)
    t3 = time.time()
    tpg = calcular_tiempo_por_grupo(pedidos, client_config, request_timeout, max_tpg)
    print(f"[TIMING] 3. Calcular tiempo grupo: {time.time() - t3:.3f}s (TPG: {tpg}s)")
    
    # 4) Ejecutar optimización VCU
    t4 = time.time()
    resultado_vcu = ejecutar_optimizacion(
        pedidos,  # No copiar - ejecutar_optimizacion no muta
        client_config, 
        "vcu", 
        tpg, 
        request_timeout
    )
    print(f"[TIMING] 4. VCU completo: {time.time() - t4:.3f}s")
    
    # 5) Ejecutar optimización BinPacking
    t5 = time.time()
    resultado_bp = ejecutar_optimizacion(
        pedidos,  # Reusar misma lista
        client_config, 
        "binpacking", 
        tpg, 
        request_timeout
    )
    print(f"[TIMING] 5. BinPacking completo: {time.time() - t5:.3f}s")
    
    # 6) Aplicar objetivo de ratio BH (si existe)
    t6 = time.time()
    try:
        from services.postprocess import enforce_bh_target
        target_ratio = getattr(client_config, "BH_TRUCK_TARGET_RATIO", None)
        if isinstance(target_ratio, (int, float)) and target_ratio > 0:
            # VCU
            cam_vcu, pni_vcu = enforce_bh_target(
                resultado_vcu.get("camiones", []),
                resultado_vcu.get("pedidos_no_incluidos", []),
                cliente, 
                float(target_ratio),
            )
            resultado_vcu["camiones"] = cam_vcu
            resultado_vcu["pedidos_no_incluidos"] = pni_vcu

            # BinPacking
            cam_bp, pni_bp = enforce_bh_target(
                resultado_bp.get("camiones", []),
                resultado_bp.get("pedidos_no_incluidos", []),
                cliente,
                float(target_ratio),
            )
            resultado_bp["camiones"] = cam_bp
            resultado_bp["pedidos_no_incluidos"] = pni_bp
            
            print(f"[TIMING] 6. Enforce BH target: {time.time() - t6:.3f}s")
    except Exception as e:
        print(f"[WARN] Error en enforce_bh_target: {e}")
    
    # 7) Etiquetado BH en BinPacking (regla especial)
    if (getattr(client_config, "PERMITE_BH", False)
            and type(client_config).__name__ != "CencosudConfig"
            and str(cliente).strip().lower() != "cencosud"):
        for cam in resultado_bp.get("camiones", []):
            if (
                cam.get("cd", [None])[0] in getattr(client_config, "CD_CON_BH", [])
                and cam.get("flujo_oc") != "MIX"
                and cam.get("vcu_max", 0) <= getattr(client_config, "BH_VCU_MAX", 1)
                and cam.get("tipo_ruta") == "normal"
            ):
                cam["tipo_camion"] = "bh"
    
    print(f"[TIMING] TOTAL optimizar_con_dos_fases: {time.time() - t_total:.3f}s")
    
    return {"vcu": resultado_vcu, "binpacking": resultado_bp}

def procesar(content, filename, client, venta, REQUEST_TIMEOUT, vcuTarget, vcuTargetBH) -> Dict[str, Any]:
    """API interna (mantener firma): lee Excel, aplica overrides y ejecuta dos fases."""
    try:
        config = get_client_config(client)
        df_full = read_file(content, filename, config, venta)

        # Overrides de thresholds (si vienen del front)
        if vcuTarget is not None:
            try:
                vcuTarget = int(vcuTarget)
                vcuTarget = max(1, min(100, vcuTarget))
                config.VCU_MIN = float(vcuTarget) / 100.0
            except Exception:
                pass
        if vcuTargetBH is not None:
            try:
                vcuTargetBH = int(vcuTargetBH)
                vcuTargetBH = max(1, min(100, vcuTargetBH))
                config.BH_VCU_MIN = float(vcuTargetBH) / 100.0
            except Exception:
                pass

        return optimizar_con_dos_fases(df_full, config, client, venta, REQUEST_TIMEOUT, MAX_TIEMPO_POR_GRUPO)

    except Exception as e:
        import traceback as _tb
        return {"error": {"message": str(e), "traceback": _tb.format_exc()[:5000]}}


# ---------------------------------------------------------
# Cálculo de grupos
# ---------------------------------------------------------

def calcular_tiempo_por_grupo(
    pedidos: List[Pedido], 
    client_config, 
    total_timeout: int, 
    max_por_grupo: int
) -> int:
    """
    Calcula tiempo asignado por grupo basándose en número de grupos.
    OPTIMIZADO: Trabaja directamente con List[Pedido].
    """
    num_grupos = _contar_grupos(pedidos, client_config)
    tiempo_total_disponible = max(total_timeout - 5, 1)
    
    if num_grupos > 0:
        tpg = tiempo_total_disponible // num_grupos
        return min(max(tpg, 1), max_por_grupo)
    
    return min(1, max_por_grupo)


def _contar_grupos(pedidos: List[Pedido], config) -> int:
    """
    Cuenta grupos de optimización sin crear DataFrame.
    OPTIMIZADO: Usa sets en vez de operaciones de pandas.
    """
    tipos_ruta = ["multi_ce_prioridad", "normal", "multi_ce", "multi_cd", "bh"]
    fases = [(tipo, config.RUTAS_POSIBLES[tipo]) for tipo in tipos_ruta if tipo in config.RUTAS_POSIBLES]
    
    lo_ag = "6009 Lo Aguirre"
    total = 0
    mix_grupos = getattr(config, "MIX_GRUPOS", [])
    usa_oc = getattr(config, "USA_OC", False)
    
    # Pre-construir sets para búsquedas O(1)
    pedidos_por_cd_ce = {}
    for p in pedidos:
        key = (p.cd, p.ce)
        if key not in pedidos_por_cd_ce:
            pedidos_por_cd_ce[key] = []
        pedidos_por_cd_ce[key].append(p)
    
    for tipo, rutas in fases:
        if tipo == "normal":
            for cds, ces in rutas:
                if cds == [lo_ag]:
                    for ce in ces:
                        pedidos_subset = pedidos_por_cd_ce.get((lo_ag, ce), [])
                        if usa_oc:
                            oc_unique = {p.oc for p in pedidos_subset if p.oc}
                            total += len(oc_unique)
                            for ocg in mix_grupos:
                                if all(o in oc_unique for o in ocg):
                                    total += 1
                        else:
                            if pedidos_subset:
                                total += 1
                else:
                    tiene_pedidos = any(
                        (cd, ce) in pedidos_por_cd_ce and pedidos_por_cd_ce[(cd, ce)]
                        for cd in cds for ce in ces
                    )
                    if tiene_pedidos:
                        total += 1
        
        elif tipo == "bh":
            for cds, ces in rutas:
                pedidos_subset = [
                    p for cd in cds for ce in ces 
                    for p in pedidos_por_cd_ce.get((cd, ce), [])
                ]
                if usa_oc and pedidos_subset:
                    total += len({p.oc for p in pedidos_subset if p.oc})
                elif pedidos_subset:
                    total += 1
        
        else:  # multi_ce, multi_cd
            for cds, ces in rutas:
                pedidos_subset = [
                    p for cd in cds for ce in ces 
                    for p in pedidos_por_cd_ce.get((cd, ce), [])
                ]
                
                if not pedidos_subset:
                    continue
                
                if cds == [lo_ag] and usa_oc:
                    total += len({p.oc for p in pedidos_subset if p.oc})
                else:
                    total += 1
    
    return total

# ---------------------------------------------------------
# Rutas, reconstrucción y heurística
# ---------------------------------------------------------

def generar_rutas(tipo: str, rutas: Iterable[Tuple[List[str], List[str]]], df: pd.DataFrame, mix_grupos: List[List[str]], usa_oc: bool):
    lo_ag = "6009 Lo Aguirre"
    rutas_iter = []

    if tipo == "normal":
        for cds, ces in rutas:
            if cds == [lo_ag]:
                df_cd = df[df["CD"] == lo_ag]
                for ce in ces:
                    df_sub = df_cd[df_cd["CE"] == ce]
                    if usa_oc:
                        oc_unique = df_sub["OC"].unique().tolist()
                        for oc in oc_unique:
                            rutas_iter.append(([lo_ag], [ce], oc))
                        for ocg in mix_grupos:
                            if all(o in oc_unique for o in ocg):
                                rutas_iter.append(([lo_ag], [ce], ocg))
                    else:
                        rutas_iter.append(([lo_ag], [ce], None))
            else:
                mask = df["CD"].isin(cds) & df["CE"].isin(ces)
                if not df[mask].empty:
                    rutas_iter.append((cds, ces, None))

    elif tipo == "bh":
        for cds, ces in rutas:
            mask = df["CD"].isin(cds) & df["CE"].isin(ces)
            df_sub = df[mask]
            if usa_oc:
                for oc in df_sub["OC"].unique().tolist():
                    rutas_iter.append((cds, ces, oc))
            else:
                rutas_iter.append((cds, ces, None))

    else:  # multi_ce y multi_cd
        for cds, ces in rutas:
            df_sub = df[df["CD"].isin(cds) & df["CE"].isin(ces)]
            if df_sub.empty:
                continue
            ce_presentes = set(df_sub["CE"].unique())
            cd_presentes = set(df_sub["CD"].unique())
            if tipo in ("multi_ce", "multi_ce_prioridad") and not all(ce in ce_presentes for ce in ces):
                continue
            if tipo == "multi_cd" and not all(cd in cd_presentes for cd in cds):
                continue
            if lo_ag in cds and usa_oc:
                for oc in df_sub["OC"].unique():
                    if not df_sub[df_sub["OC"] == oc].empty:
                        rutas_iter.append((cds, ces, oc))
            else:
                rutas_iter.append((cds, ces, None))

    return rutas_iter


def completar_metadata_pedido(pedido_minimal: dict, raw_map: dict) -> dict:
    p = pedido_minimal["PEDIDO"]
    completo = pedido_minimal.copy()
    if p not in raw_map:
        return completo
    for clave, valor in raw_map[p].items():
        if clave not in completo:
            completo[clave] = valor
    return completo


def heuristica_ffd(pedidos: List[Any], peso_raw: Dict[Any, float], vol_raw: Dict[Any, float], truck_caps: Dict[str, float]) -> int:
    cap_weight = truck_caps["cap_weight"]
    cap_volume = truck_caps["cap_volume"]
    pedidos_orden = sorted(
        pedidos,
        key=lambda i: max(peso_raw[i] / cap_weight, vol_raw[i] / cap_volume),
        reverse=True,
    )
    camiones: List[Tuple[float, float]] = []
    for i in pedidos_orden:
        for idx in range(len(camiones)):
            if camiones[idx][0] + peso_raw[i] <= cap_weight and camiones[idx][1] + vol_raw[i] <= cap_volume:
                camiones[idx] = (camiones[idx][0] + peso_raw[i], camiones[idx][1] + vol_raw[i])
                break
        else:
            camiones.append((peso_raw[i], vol_raw[i]))
    return len(camiones)


# ---------------------------------------------------------
# Núcleo: CP-SAT VCU y BinPacking
# ---------------------------------------------------------

# services/optimizer.py (reemplazar la función ejecutar_optimizacion)

def ejecutar_optimizacion(
    pedidos: List[Pedido],
    client_config,
    modo: str,
    tiempo_por_grupo: int,
    REQUEST_TIMEOUT: int
) -> Dict[str, Any]:
    """
    Ejecuta optimización por fases según modo (VCU o BinPacking).
    
    REFACTORIZADO: Trabaja con List[Pedido] en vez de DataFrame.
    
    Args:
        pedidos: Lista completa de pedidos
        client_config: Configuración del cliente
        modo: "vcu" o "binpacking"
        tiempo_por_grupo: Tiempo máximo por grupo en segundos
        REQUEST_TIMEOUT: Timeout total de la request
    
    Returns:
        Dict con camiones y pedidos no incluidos
    """
    # 1) Extraer capacidades
    capacidades = extract_truck_capacities(client_config)
    capacidad_normal = capacidades[TipoCamion.NORMAL]
    capacidad_bh = capacidades.get(TipoCamion.BH, capacidad_normal)
    
    # 2) Determinar tipos de ruta y rutas según modo
    if modo == "binpacking":
        tipos_ruta = getattr(client_config, "BINPACKING_TIPOS_RUTA", ["normal"]) or ["normal"]
        rutas_bp = getattr(client_config, "RUTAS_BINPACKING", {})
        rutas_for = lambda t: rutas_bp.get(t, client_config.RUTAS_POSIBLES.get(t, []))
    else:
        tipos_ruta = ["multi_ce_prioridad", "normal", "multi_ce", "multi_cd", "bh"]
        rutas_for = lambda t: client_config.RUTAS_POSIBLES.get(t, [])
    
    fases = [(t, rutas_for(t)) for t in tipos_ruta if rutas_for(t)]
    
    # 3) Inicializar estado
    pedidos_restantes = pedidos.copy()
    camiones_resultado: List[Camion] = []
    start_total = time.time()
    
    mix_grupos = getattr(client_config, "MIX_GRUPOS", [])
    usa_oc = getattr(client_config, "USA_OC", False)
    
    # 4) Iterar por fases (tipos de ruta)
    for tipo, rutas in fases:
        if not pedidos_restantes:
            break
        
        if time.time() - start_total > (REQUEST_TIMEOUT - 2):
            break
        
        # Determinar capacidad según tipo de ruta
        if tipo == TipoRuta.BH or tipo == "bh":
            capacidad_fase = capacidad_bh
        else:
            capacidad_fase = capacidad_normal
        
        # Generar grupos de optimización
        grupos = _generar_grupos_optimizacion(
            pedidos_restantes, tipo, rutas, mix_grupos, usa_oc, client_config
        )
        
        if not grupos:
            continue
        
        # Ejecutar optimización por grupo
        if tipo == TipoRuta.NORMAL or tipo == "normal":
            # Paralelización para rutas normales
            camiones_fase = _optimizar_grupos_paralelo(
                grupos, pedidos_restantes, client_config, modo, 
                tiempo_por_grupo, REQUEST_TIMEOUT, start_total, capacidad_fase
            )
        else:
            # Secuencial para otros tipos
            camiones_fase = _optimizar_grupos_secuencial(
                grupos, pedidos_restantes, client_config, modo,
                tiempo_por_grupo, REQUEST_TIMEOUT, start_total, capacidad_fase
            )
        
        # Actualizar estado
        camiones_resultado.extend(camiones_fase)
        
        # Remover pedidos asignados
        pedidos_asignados_ids = {
            p.pedido for c in camiones_fase for p in c.pedidos
        }
        pedidos_restantes = [
            p for p in pedidos_restantes 
            if p.pedido not in pedidos_asignados_ids
        ]
    
    # 5) Construir resultado final
    return {
        'camiones': [c.to_api_dict() for c in camiones_resultado],
        'pedidos_no_incluidos': [
            p.to_api_dict(capacidad_normal) 
            for p in pedidos_restantes
        ]
    }


def _generar_grupos_optimizacion(
    pedidos: List[Pedido],
    tipo: str,
    rutas: List[Tuple[List[str], List[str]]],
    mix_grupos: List[List[str]],
    usa_oc: bool,
    client_config
) -> List[Tuple[ConfiguracionGrupo, List[Pedido]]]:
    """
    Genera grupos de optimización (configuración + pedidos filtrados).
    
    Returns:
        Lista de tuplas (ConfiguracionGrupo, pedidos_del_grupo)
    """
    grupos = []
    lo_aguirre = "6009 Lo Aguirre"
    
    # Convertir string a TipoRuta
    try:
        tipo_enum = TipoRuta(tipo)
    except ValueError:
        tipo_enum = TipoRuta.NORMAL
    
    if tipo in ("normal", TipoRuta.NORMAL):
        # Rutas normales: pueden tener subdivisión por OC
        for cds, ces in rutas:
            if cds == [lo_aguirre]:
                # Lo Aguirre: subdividir por CE y OC
                for ce in ces:
                    pedidos_ce = [
                        p for p in pedidos 
                        if p.cd == lo_aguirre and p.ce == ce
                    ]
                    
                    if not pedidos_ce:
                        continue
                    
                    if usa_oc:
                        # Subdividir por OC individual
                        ocs_unicas = {p.oc for p in pedidos_ce if p.oc}
                        for oc in ocs_unicas:
                            pedidos_oc = [p for p in pedidos_ce if p.oc == oc]
                            cfg = ConfiguracionGrupo(
                                id=f"normal__{lo_aguirre}__{ce}__{oc}",
                                tipo=tipo_enum,
                                ce=[ce],
                                cd=[lo_aguirre],
                                oc=oc
                            )
                            grupos.append((cfg, pedidos_oc))
                        
                        # Grupos MIX
                        for ocg in mix_grupos:
                            if all(o in ocs_unicas for o in ocg):
                                pedidos_mix = [p for p in pedidos_ce if p.oc in ocg]
                                cfg = ConfiguracionGrupo(
                                    id=f"normal__{lo_aguirre}__{ce}__{'_'.join(ocg)}",
                                    tipo=tipo_enum,
                                    ce=[ce],
                                    cd=[lo_aguirre],
                                    oc=ocg
                                )
                                grupos.append((cfg, pedidos_mix))
                    else:
                        # Sin OC
                        cfg = ConfiguracionGrupo(
                            id=f"normal__{lo_aguirre}__{ce}",
                            tipo=tipo_enum,
                            ce=[ce],
                            cd=[lo_aguirre],
                            oc=None
                        )
                        grupos.append((cfg, pedidos_ce))
            else:
                # Otras rutas normales
                pedidos_ruta = [
                    p for p in pedidos 
                    if p.cd in cds and p.ce in ces
                ]
                
                if pedidos_ruta:
                    cfg = ConfiguracionGrupo(
                        id=f"normal__{'_'.join(cds)}__{'_'.join(ces)}",
                        tipo=tipo_enum,
                        ce=ces,
                        cd=cds,
                        oc=None
                    )
                    grupos.append((cfg, pedidos_ruta))
    
    elif tipo in ("bh", TipoRuta.BH):
        # Rutas BH: subdividir por OC si aplica
        for cds, ces in rutas:
            pedidos_ruta = [
                p for p in pedidos 
                if p.cd in cds and p.ce in ces
            ]
            
            if not pedidos_ruta:
                continue
            
            if usa_oc:
                ocs_unicas = {p.oc for p in pedidos_ruta if p.oc}
                for oc in ocs_unicas:
                    pedidos_oc = [p for p in pedidos_ruta if p.oc == oc]
                    cfg = ConfiguracionGrupo(
                        id=f"bh__{'_'.join(cds)}__{'_'.join(ces)}__{oc}",
                        tipo=TipoRuta.BH,
                        ce=ces,
                        cd=cds,
                        oc=oc
                    )
                    grupos.append((cfg, pedidos_oc))
            else:
                cfg = ConfiguracionGrupo(
                    id=f"bh__{'_'.join(cds)}__{'_'.join(ces)}",
                    tipo=TipoRuta.BH,
                    ce=ces,
                    cd=cds,
                    oc=None
                )
                grupos.append((cfg, pedidos_ruta))
    
    else:
        # Multi-CE, Multi-CD, etc.
        for cds, ces in rutas:
            pedidos_ruta = [
                p for p in pedidos 
                if p.cd in cds and p.ce in ces
            ]
            
            if not pedidos_ruta:
                continue
            
            # Validar que se cumplan los requisitos del tipo
            ce_presentes = {p.ce for p in pedidos_ruta}
            cd_presentes = {p.cd for p in pedidos_ruta}
            
            if tipo in ("multi_ce", "multi_ce_prioridad"):
                if not all(ce in ce_presentes for ce in ces):
                    continue
            
            if tipo == "multi_cd":
                if not all(cd in cd_presentes for cd in cds):
                    continue
            
            # Subdividir por OC si es Lo Aguirre
            if lo_aguirre in cds and usa_oc:
                ocs_unicas = {p.oc for p in pedidos_ruta if p.oc}
                for oc in ocs_unicas:
                    pedidos_oc = [p for p in pedidos_ruta if p.oc == oc]
                    if pedidos_oc:
                        cfg = ConfiguracionGrupo(
                            id=f"{tipo}__{'_'.join(cds)}__{'_'.join(ces)}__{oc}",
                            tipo=tipo_enum,
                            ce=ces,
                            cd=cds,
                            oc=oc
                        )
                        grupos.append((cfg, pedidos_oc))
            else:
                cfg = ConfiguracionGrupo(
                    id=f"{tipo}__{'_'.join(cds)}__{'_'.join(ces)}",
                    tipo=tipo_enum,
                    ce=ces,
                    cd=cds,
                    oc=None
                )
                grupos.append((cfg, pedidos_ruta))
    
    return grupos


def _optimizar_grupos_paralelo(
    grupos: List[Tuple[ConfiguracionGrupo, List[Pedido]]],
    pedidos_restantes: List[Pedido],
    client_config,
    modo: str,
    tiempo_por_grupo: int,
    REQUEST_TIMEOUT: int,
    start_total: float,
    capacidad: TruckCapacity
) -> List[Camion]:
    """
    Optimiza grupos en paralelo (para rutas normales).
    """
    from concurrent.futures import ThreadPoolExecutor, as_completed
    
    camiones = []
    pedidos_asignados_ids_global = set()
    
    futures = []
    with ThreadPoolExecutor(max_workers=min(THREAD_WORKERS_NORMAL, len(grupos))) as pool:
        for cfg, pedidos_grupo in grupos:
            if not pedidos_grupo:
                continue
            
            tiempo_grupo = max(1, int(tiempo_por_grupo * len(pedidos_grupo) / 10))
            
            if time.time() - start_total + tiempo_grupo > (REQUEST_TIMEOUT - 2):
                continue
            
            # Lanzar optimización
            if modo == "vcu":
                fut = pool.submit(
                    optimizar_vcu, pedidos_grupo, cfg, 
                    client_config, tiempo_grupo, capacidad
                )
            else:
                fut = pool.submit(
                    optimizar_bin, pedidos_grupo, cfg,
                    client_config, tiempo_grupo, capacidad
                )
            
            futures.append(fut)
        
        # Recolectar resultados
        for fut in as_completed(futures, timeout=max(1, REQUEST_TIMEOUT - int(time.time() - start_total))):
            try:
                res = fut.result()
            except Exception as e:
                print(f"[ERROR] Grupo falló: {e}")
                continue
            
            if res.get("status") not in ("OPTIMAL", "FEASIBLE"):
                continue
            
            if not res.get("camiones"):
                continue
            
            # Verificar que no haya duplicados
            nuevos_ids = set(res.get("pedidos_asignados_ids", []))
            if nuevos_ids & pedidos_asignados_ids_global:
                continue  # Ya asignados en otro grupo
            
            pedidos_asignados_ids_global.update(nuevos_ids)
            
            # Convertir dicts a objetos Camion
            for cam_dict in res["camiones"]:
                camion = _camion_from_dict(cam_dict, capacidad)
                camiones.append(camion)
    
    return camiones


def _optimizar_grupos_secuencial(
    grupos: List[Tuple[ConfiguracionGrupo, List[Pedido]]],
    pedidos_restantes: List[Pedido],
    client_config,
    modo: str,
    tiempo_por_grupo: int,
    REQUEST_TIMEOUT: int,
    start_total: float,
    capacidad: TruckCapacity
) -> List[Camion]:
    """
    Optimiza grupos secuencialmente.
    """
    camiones = []
    
    for cfg, pedidos_grupo in grupos:
        if not pedidos_grupo:
            continue
        
        tiempo_grupo = max(1, int(tiempo_por_grupo * len(pedidos_grupo) / 10))
        
        if time.time() - start_total + tiempo_grupo > (REQUEST_TIMEOUT - 2):
            break
        
        # Ejecutar optimización
        if modo == "vcu":
            res = optimizar_vcu(
                pedidos_grupo, cfg, client_config, tiempo_grupo, capacidad
            )
        else:
            res = optimizar_bin(
                pedidos_grupo, cfg, client_config, tiempo_grupo, capacidad
            )
        
        if res.get("status") not in ("OPTIMAL", "FEASIBLE"):
            continue
        
        if not res.get("camiones"):
            continue
        
        # Convertir dicts a objetos Camion
        for cam_dict in res["camiones"]:
            camion = _camion_from_dict(cam_dict, capacidad)
            camiones.append(camion)
    
    return camiones


def _camion_from_dict(cam_dict: Dict[str, Any], capacidad: TruckCapacity) -> Camion:
    """
    Reconstruye un objeto Camion desde el diccionario retornado por el solver.
    """
    # Los pedidos ya vienen como dicts en cam_dict["pedidos"]
    pedidos_objs = []
    
    for p_dict in cam_dict.get("pedidos", []):
        # Reconstruir Pedido desde dict
        pedido = Pedido(
            pedido=p_dict["PEDIDO"],
            cd=p_dict["CD"],
            ce=p_dict["CE"],
            po=p_dict["PO"],
            peso=p_dict["PESO"],
            volumen=p_dict["VOL"],
            pallets=p_dict["PALLETS"],
            valor=p_dict["VALOR"],
            valor_cafe=p_dict.get("VALOR_CAFE", 0),
            pallets_real=p_dict.get("PALLETS_REAL"),
            oc=p_dict.get("OC"),
            chocolates=p_dict.get("CHOCOLATES", "NO"),
            valioso=bool(p_dict.get("VALIOSO", 0)),
            pdq=bool(p_dict.get("PDQ", 0)),
            baja_vu=bool(p_dict.get("BAJA_VU", 0)),
            lote_dir=bool(p_dict.get("LOTE_DIR", 0)),
            base=p_dict.get("BASE", 0),
            superior=p_dict.get("SUPERIOR", 0),
            flexible=p_dict.get("FLEXIBLE", 0),
            no_apilable=p_dict.get("NO_APILABLE", 0),
            si_mismo=p_dict.get("SI_MISMO", 0),
            metadata={k: v for k, v in p_dict.items() if k not in {
                "PEDIDO", "CD", "CE", "PO", "PESO", "VOL", "PALLETS", "PALLETS_REAL",
                "VALOR", "VALOR_CAFE", "OC", "CHOCOLATES", "VALIOSO", "PDQ",
                "BAJA_VU", "LOTE_DIR", "BASE", "SUPERIOR", "FLEXIBLE",
                "NO_APILABLE", "SI_MISMO", "VCU_VOL", "VCU_PESO", "CAMION",
                "GRUPO", "TIPO_RUTA", "TIPO_CAMION"
            }}
        )
        pedidos_objs.append(pedido)
    
    # Crear camión
    camion = Camion(
        id=cam_dict["id"],
        tipo_ruta=TipoRuta(cam_dict["tipo_ruta"]),
        tipo_camion=TipoCamion(cam_dict["tipo_camion"]),
        cd=cam_dict["cd"],
        ce=cam_dict["ce"],
        grupo=cam_dict["grupo"],
        capacidad=capacidad,
        pedidos=pedidos_objs,
        opciones_tipo_camion=cam_dict.get("opciones_tipo_camion", ["normal"])
    )
    
    # Setear pos_total si viene
    if "pos_total" in cam_dict:
        camion.pos_total = cam_dict["pos_total"]
    
    return camion

# ---------------------------------------------------------
# Post-procesado de camiones (flujo OC + chocolates)
# ---------------------------------------------------------

def postprocesar_camiones(camiones: List[Dict[str, Any]], config) -> List[Dict[str, Any]]:
    for cam in camiones:
        if getattr(config, "USA_OC", False):
            ocs = {p.get("OC") for p in cam.get("pedidos", []) if p.get("OC")}
            cam["flujo_oc"] = next(iter(ocs)) if len(ocs) == 1 else ("MIX" if ocs else None)
        else:
            cam["flujo_oc"] = None
        cam["chocolates"] = "SI" if any(p.get("CHOCOLATES") == "SI" for p in cam.get("pedidos", [])) else "NO"

        # Opciones de cambio de tipo (se calculan con los campos ya presentes del camión)
        switch_info = _build_switch_options_for_truck(cam, config)
        cam['can_switch_tipo_camion'] = switch_info['can_switch']
        cam['opciones_tipo_camion'] = switch_info['opciones']
    return camiones


# =========================================================
# Helpers para opciones de cambio de tipo de camión
# =========================================================
def _ruta_coincide_con_bh(cds_cam: List[str], ces_cam: List[int], rutas_bh: List) -> bool:
    """
    Retorna True si el par (cds_cam, ces_cam) calza con alguna ruta BH declarada
    en RUTAS_POSIBLES['bh'] (subset match).
    """
    set_cd = set(cds_cam or [])
    set_ce = set(ces_cam or [])
    for cds, ces in rutas_bh or []:
        if set_cd.issubset(set(cds)) and set_ce.issubset(set(ces)):
            return True
    return False


def _build_switch_options_for_truck(cam: Dict[str, Any], client_config) -> Dict[str, Any]:
    """
    Construye las opciones de 'tipo_camion' disponibles para un camión dado,
    en base a la configuración del cliente y a los atributos del camión.
    Devuelve: {'can_switch': bool, 'opciones': [actual, ...]}
    """
    actual = (cam.get('tipo_camion') or 'normal').lower()
    opciones = ['normal']  # siempre permitir volver a 'normal'

    # Reglas BH (si el cliente lo permite)
    if getattr(client_config, 'PERMITE_BH', False):
        rutas_bh = getattr(client_config, 'RUTAS_POSIBLES', {}).get('bh', [])
        ruta_ok = _ruta_coincide_con_bh(cam.get('cd'), cam.get('ce'), rutas_bh)

        # Si existe lista de CDs que admiten BH, respetarla (si no existe, lo damos por OK)
        cd_ok = True
        if hasattr(client_config, 'CD_CON_BH'):
            cd_ok = all(cd in client_config.CD_CON_BH for cd in (cam.get('cd') or []))

        # Mezcla de flujos: por defecto no, salvo flag explícito
        permite_mix = getattr(client_config, 'BH_PERMITE_MIX', False)
        flujo = cam.get('flujo_oc')
        flujo_ok = True if permite_mix else (flujo not in ('MIX',))

        # Ventanas de VCU para BH (si existen en config)
        vcu = float(cam.get('vcu_max') or 0.0)
        vcu_ok = True
        if hasattr(client_config, 'BH_VCU_MAX'):
            vcu_ok = vcu_ok and (vcu <= float(client_config.BH_VCU_MAX))
        if hasattr(client_config, 'BH_VCU_MIN'):
            vcu_ok = vcu_ok and (vcu >= float(client_config.BH_VCU_MIN))

        if ruta_ok and cd_ok and flujo_ok and vcu_ok:
            opciones.append('bh')

    # Unificar y poner el actual primero
    seen = set()
    opciones = [o for o in ([actual] + [o for o in opciones if o != actual]) if not (o in seen or seen.add(o))]
    return {
        'can_switch': len(opciones) > 1,
        'opciones': opciones
    }

# ---------------------------------------------------------
# Modelos CP-SAT (VCU y BinPacking)
# ---------------------------------------------------------


# services/optimizer.py

def optimizar_vcu(
    pedidos: List[Pedido],
    grupo_cfg: ConfiguracionGrupo,
    client_config,
    tiempo_max_seg: int,
    capacidad: TruckCapacity
) -> Dict[str, Any]:
    """
    Optimización por VCU usando CP-SAT.
    
    REFACTORIZADO: Trabaja directamente con List[Pedido].
    
    Args:
        pedidos: Lista de pedidos a optimizar
        grupo_cfg: Configuración del grupo (ruta, CD, CE, OC)
        client_config: Configuración del cliente
        tiempo_max_seg: Tiempo máximo en segundos
        capacidad: Capacidad del camión a usar
    
    Returns:
        Dict con resultado de optimización (formato legacy para compatibilidad)
    """
    from ortools.sat.python import cp_model
    
    # 1) Filtrar pedidos que pertenecen a este grupo
    pedidos_grupo = agrupar_pedidos_por_criterio(pedidos, grupo_cfg)
    
    if not pedidos_grupo:
        return {
            'status': StatusOptimizacion.NO_SOLUTION.value,
            'pedidos_asignados_ids': [],
            'pedidos_asignados': [],
            'pedidos_excluidos': [],
            'camiones': []
        }
    
    # 2) Filtrar pedidos que pueden caber individualmente
    pedidos_validos = filtrar_pedidos_validos(pedidos_grupo, capacidad)
    
    if not pedidos_validos:
        # Todos los pedidos exceden capacidad individual
        return {
            'status': StatusOptimizacion.NO_SOLUTION.value,
            'pedidos_asignados_ids': [],
            'pedidos_asignados': [],
            'pedidos_excluidos': [p.to_api_dict(capacidad) for p in pedidos_grupo],
            'camiones': []
        }
    
    # 3) Preparar datos para el solver
    datos = preparar_datos_solver(pedidos_validos, capacidad)
    pedidos_ids = list(datos.keys())
    
    # 4) Estimar número de camiones con heurística
    n_cam_heur = heuristica_ffd_pedidos(pedidos_validos, capacidad)
    n_cam = min(len(pedidos_validos), n_cam_heur, MAX_CAMIONES_CP_SAT)
    
    # 5) Construir modelo CP-SAT
    model = cp_model.CpModel()
    
    # Variables x[(pedido_id, camion_idx)]
    x = {}
    for pid in pedidos_ids:
        for j in range(n_cam):
            x[(pid, j)] = model.NewBoolVar(f"x_vcu_{pid}_{j}")
    
    # Variables y[camion_idx] (camión usado)
    y_truck = {j: model.NewBoolVar(f"y_vcu_truck_{j}") for j in range(n_cam)}
    
    # 6) Agregaciones por camión
    vol_cam_int = {}
    peso_cam_int = {}
    vcu_max_int = {}
    
    for j in range(n_cam):
        # Suma de VCU escalados
        vol_cam_int[j] = sum(datos[pid]['vcu_vol_int'] * x[(pid, j)] for pid in pedidos_ids)
        peso_cam_int[j] = sum(datos[pid]['vcu_peso_int'] * x[(pid, j)] for pid in pedidos_ids)
        
        # VCU máximo del camión
        v = model.NewIntVar(0, SCALE_VCU, f"vcu_max_int_{j}")
        model.AddMaxEquality(v, [vol_cam_int[j], peso_cam_int[j]])
        vcu_max_int[j] = v
    
    # 7) Restricciones básicas
    
    # Cada pedido a máximo un camión
    for pid in pedidos_ids:
        vars_pedido = [x[(pid, j)] for j in range(n_cam)]
        model.Add(sum(vars_pedido) <= 1)
    
    # Activar camión solo si tiene pedidos
    for pid in pedidos_ids:
        for j in range(n_cam):
            model.Add(x[(pid, j)] <= y_truck[j])
    
    # Monotonía: camiones se usan en orden
    for j in range(1, n_cam):
        model.Add(y_truck[j] <= y_truck[j - 1])
    
    # 8) Restricciones de capacidad
    vcu_min_int = int(round(capacidad.vcu_min * SCALE_VCU))
    max_positions = capacidad.max_positions
    max_pallets = capacidad.max_pallets
    levels = capacidad.levels
    
    for j in range(n_cam):
        # VCU mínimo (solo si camión está activo)
        model.Add(vcu_max_int[j] >= vcu_min_int).OnlyEnforceIf(y_truck[j])
        
        # Capacidad dura: no exceder 100% (SCALE_VCU = 100%)
        model.Add(vol_cam_int[j] <= SCALE_VCU * y_truck[j])
        model.Add(peso_cam_int[j] <= SCALE_VCU * y_truck[j])
        model.Add(vcu_max_int[j] <= SCALE_VCU * y_truck[j])
        
        # Al menos un pedido por camión activo
        model.Add(sum(x[(pid, j)] for pid in pedidos_ids) >= y_truck[j])
        
        # Pallets configurados
        pallets_total = sum(datos[pid]['pallets_cap_int'] * x[(pid, j)] for pid in pedidos_ids)
        model.Add(pallets_total <= max_pallets * SCALE_PALLETS * y_truck[j])
        
        # Número máximo de órdenes (Walmart)
        if client_config.__name__ == 'WalmartConfig':
            if grupo_cfg.tipo == TipoRuta.MULTI_CD:
                # Máximo 10 por CD, 20 total
                cds_en_grupo = {datos[pid]['cd'] for pid in pedidos_ids}
                for cd in cds_en_grupo:
                    pedidos_cd = [pid for pid in pedidos_ids if datos[pid]['cd'] == cd]
                    if pedidos_cd:
                        model.Add(sum(x[(pid, j)] for pid in pedidos_cd) <= 10 * y_truck[j])
                model.Add(sum(x[(pid, j)] for pid in pedidos_ids) <= 20 * y_truck[j])
            else:
                max_ordenes = getattr(client_config, 'MAX_ORDENES', 10)
                model.Add(sum(x[(pid, j)] for pid in pedidos_ids) <= max_ordenes * y_truck[j])
        
        # === RESTRICCIONES DE APILABILIDAD ===
        _agregar_restricciones_apilabilidad(
            model, x, datos, pedidos_ids, j, y_truck[j], 
            max_positions, levels, SCALE_PALLETS
        )
    
    # 9) Agrupación por PO (si aplica)
    if client_config.AGRUPAR_POR_PO:
        _agregar_restricciones_agrupacion_por_po_v2(
            model, x, datos, pedidos_ids, n_cam
        )
    
    # 10) Función objetivo
    obj_terms = []
    
    # Maximizar VCU
    for j in range(n_cam):
        obj_terms.append(PESO_VCU * vcu_max_int[j])
    
    # Maximizar pedidos incluidos
    for pid in pedidos_ids:
        for j in range(n_cam):
            obj_terms.append(PESO_PEDIDOS * x[(pid, j)])
    
    # Minimizar camiones
    for j in range(n_cam):
        obj_terms.append(-(PESO_CAMIONES * SCALE_VCU) * y_truck[j])
    
    model.Maximize(sum(obj_terms))
    
    # 11) Resolver
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = float(tiempo_max_seg)
    solver.parameters.num_search_workers = 1

    solver.parameters.log_search_progress = False  # No loggear (ahorra tiempo)
    solver.parameters.cp_model_presolve = True     # Simplificar modelo antes de resolver
    solver.parameters.linearization_level = 2      # Máxima linearización
    solver.parameters.symmetry_level = 2           # Detectar simetrías
    
    t0 = time.time()
    resultado = solver.Solve(model)
    t1 = time.time()
    
    status_map = {
        cp_model.OPTIMAL: StatusOptimizacion.OPTIMAL,
        cp_model.FEASIBLE: StatusOptimizacion.FEASIBLE
    }
    estado = status_map.get(resultado, StatusOptimizacion.NO_SOLUTION)
    
    print(f"[TIMING] CP-SAT (VCU) grupo {grupo_cfg.id}: {t1 - t0:.3f}s, estado: {estado.value}")
    
    # 12) Reconstruir solución
    if estado == StatusOptimizacion.NO_SOLUTION:
        return {
            'status': estado.value,
            'pedidos_asignados_ids': [],
            'pedidos_asignados': [],
            'pedidos_excluidos': [p.to_api_dict(capacidad) for p in pedidos_validos],
            'camiones': []
        }
    
    camiones: List[Camion] = []
    pedidos_asignados_ids = []
    
    for j in range(n_cam):
        if solver.Value(y_truck[j]) < 1:
            continue
        
        # Pedidos asignados a este camión
        pids_camion = [pid for pid in pedidos_ids if solver.Value(x[(pid, j)]) == 1]
        
        if not pids_camion:
            continue
        
        pedidos_asignados_ids.extend(pids_camion)
        
        # Reconstruir camión
        camion = reconstruir_camion_desde_solver(
            pids_camion, datos, grupo_cfg, capacidad, len(camiones) + 1
        )
        
        # Calcular posiciones de apilabilidad
        pos_total = calcular_posiciones_apilabilidad(camion.pedidos, max_positions)
        camion.pos_total = pos_total
        
        camiones.append(camion)
    
    # Pedidos no incluidos
    pedidos_excluidos = [
        p for p in pedidos_validos 
        if p.pedido not in pedidos_asignados_ids
    ]
    
    return {
        'status': estado.value,
        'pedidos_asignados_ids': pedidos_asignados_ids,
        'pedidos_asignados': [
            p.to_api_dict(capacidad) 
            for c in camiones 
            for p in c.pedidos
        ],
        'pedidos_excluidos': [p.to_api_dict(capacidad) for p in pedidos_excluidos],
        'camiones': [c.to_api_dict() for c in camiones]
    }


def _agregar_restricciones_apilabilidad(
    model, x, datos, pedidos_ids, j, y_truck_j, 
    max_positions, levels, scale
):
    """Agrega restricciones de apilabilidad al modelo CP-SAT."""
    lim_pos_scaled = max_positions * scale
    
    # Sumas por tipo
    base_sum = sum(datos[pid]['base_int'] * x[(pid, j)] for pid in pedidos_ids)
    sup_sum = sum(datos[pid]['superior_int'] * x[(pid, j)] for pid in pedidos_ids)
    flex_sum = sum(datos[pid]['flexible_int'] * x[(pid, j)] for pid in pedidos_ids)
    noap_sum = sum(datos[pid]['no_apil_int'] * x[(pid, j)] for pid in pedidos_ids)
    self_sum = sum(datos[pid]['si_mismo_int'] * x[(pid, j)] for pid in pedidos_ids)
    
    # Límites individuales
    model.Add(base_sum <= lim_pos_scaled * y_truck_j)
    model.Add(sup_sum <= lim_pos_scaled * y_truck_j)
    model.Add(noap_sum <= lim_pos_scaled * y_truck_j)
    model.Add(flex_sum <= max_positions * levels * scale * y_truck_j)
    
    # Combinaciones
    model.Add((base_sum + noap_sum) <= lim_pos_scaled * y_truck_j)
    model.Add((sup_sum + noap_sum) <= lim_pos_scaled * y_truck_j)
    
    # === FIX: Crear variables intermedias para evitar error de tipos ===
    
    # En vez de: diff = base_sum - sup_sum (puede fallar con IntAffine)
    # Usamos: model.Add(diff == base_sum - sup_sum) con IntVar intermedia
    
    diff = model.NewIntVar(-lim_pos_scaled, lim_pos_scaled, f"diff_{j}")
    # Truco: diff = base_sum + (-1 * sup_sum) en vez de resta directa
    model.Add(diff == base_sum + (-1) * sup_sum)
    
    abs_diff = model.NewIntVar(0, lim_pos_scaled, f"abs_diff_{j}")
    model.AddAbsEquality(abs_diff, diff)
    
    # m0 = min(base_sum, superior_sum)
    m0 = model.NewIntVar(0, lim_pos_scaled, f"m0_{j}")
    b0 = model.NewBoolVar(f"b0_{j}")
    model.Add(base_sum <= sup_sum).OnlyEnforceIf(b0)
    model.Add(base_sum > sup_sum).OnlyEnforceIf(b0.Not())
    model.Add(m0 == base_sum).OnlyEnforceIf(b0)
    model.Add(m0 == sup_sum).OnlyEnforceIf(b0.Not())
    
    # m1 = min(abs_diff, flex_sum)
    m1 = model.NewIntVar(0, lim_pos_scaled, f"m1_{j}")
    b1 = model.NewBoolVar(f"b1_{j}")
    model.Add(abs_diff <= flex_sum).OnlyEnforceIf(b1)
    model.Add(abs_diff > flex_sum).OnlyEnforceIf(b1.Not())
    model.Add(m1 == abs_diff).OnlyEnforceIf(b1)
    model.Add(m1 == flex_sum).OnlyEnforceIf(b1.Not())
    
    # rem = flex_sum - m1
    rem = model.NewIntVar(0, lim_pos_scaled, f"rem_{j}")
    # FIX: Usar suma con negativo en vez de resta directa
    model.Add(rem == flex_sum + (-1) * m1)
    
    # half = ceil(rem/2)
    half = model.NewIntVar(0, lim_pos_scaled, f"half_{j}")
    model.Add(2 * half >= rem)
    model.Add(2 * half <= rem + 1)
    
    # m2 = max(abs_diff - flex_sum, 0)
    m2 = model.NewIntVar(0, lim_pos_scaled, f"m2_{j}")
    b2 = model.NewBoolVar(f"b2_{j}")
    model.Add(abs_diff >= flex_sum).OnlyEnforceIf(b2)
    model.Add(abs_diff < flex_sum).OnlyEnforceIf(b2.Not())
    # FIX: Usar suma con negativo
    model.Add(m2 == abs_diff + (-1) * flex_sum).OnlyEnforceIf(b2)
    model.Add(m2 == 0).OnlyEnforceIf(b2.Not())
    
    # SI_MISMO
    self_sum_var = model.NewIntVar(0, max_positions * scale * levels * 2, f"self_sum_{j}")
    model.Add(self_sum_var == self_sum)
    
    pair_q = model.NewIntVar(0, max_positions, f"self_pairs_q_{j}")
    model.AddDivisionEquality(pair_q, self_sum_var, 2 * scale)
    
    self_rem = model.NewIntVar(0, 2 * scale - 1, f"self_rem_{j}")
    # FIX: Usar suma con negativo
    model.Add(self_rem == self_sum_var + (-1) * (pair_q * (2 * scale)))
    
    self_pairs_scaled = model.NewIntVar(0, lim_pos_scaled, f"self_pairs_scaled_{j}")
    model.Add(self_pairs_scaled == pair_q * scale)
    
    # Total stack
    total_stack = model.NewIntVar(-lim_pos_scaled * 2, lim_pos_scaled * 4, f"total_stack_{j}")
    model.Add(total_stack == m0 + m1 + half + m2 + noap_sum + self_pairs_scaled + self_rem)
    model.Add(total_stack <= lim_pos_scaled * y_truck_j)

def _agregar_restricciones_agrupacion_por_po_v2(model, x, datos, pedidos_ids, n_cam):
    """Agrupa pedidos del mismo PO en el mismo camión"""
    po_grupos = {}
    for pid in pedidos_ids:
        po = datos[pid]['po']
        po_grupos.setdefault(po, []).append(pid)
    
    for po, pids in po_grupos.items():
        if len(pids) <= 1:
            continue
        for j in range(n_cam):
            for idx in range(1, len(pids)):
                p1, p2 = pids[0], pids[idx]
                model.Add(x[(p1, j)] == x[(p2, j)])

# services/optimizer.py (agregar después de optimizar_vcu)

def optimizar_bin(
    pedidos: List[Pedido],
    grupo_cfg: ConfiguracionGrupo,
    client_config,
    tiempo_max_seg: int,
    capacidad: TruckCapacity
) -> Dict[str, Any]:
    """
    Optimización por BinPacking usando CP-SAT.
    Minimiza el número de camiones necesarios.
    
    REFACTORIZADO: Trabaja directamente con List[Pedido].
    
    Args:
        pedidos: Lista de pedidos a optimizar
        grupo_cfg: Configuración del grupo (ruta, CD, CE, OC)
        client_config: Configuración del cliente
        tiempo_max_seg: Tiempo máximo en segundos
        capacidad: Capacidad del camión a usar
    
    Returns:
        Dict con resultado de optimización (formato legacy para compatibilidad)
    """
    from ortools.sat.python import cp_model
    
    # 1) Filtrar pedidos que pertenecen a este grupo
    pedidos_grupo = agrupar_pedidos_por_criterio(pedidos, grupo_cfg)
    
    if not pedidos_grupo:
        return {
            'status': StatusOptimizacion.NO_SOLUTION.value,
            'pedidos_asignados_ids': [],
            'pedidos_asignados': [],
            'pedidos_excluidos': [],
            'camiones': []
        }
    
    # 2) Filtrar pedidos que pueden caber individualmente
    pedidos_validos = filtrar_pedidos_validos(pedidos_grupo, capacidad)
    
    if not pedidos_validos:
        return {
            'status': StatusOptimizacion.NO_SOLUTION.value,
            'pedidos_asignados_ids': [],
            'pedidos_asignados': [],
            'pedidos_excluidos': [p.to_api_dict(capacidad) for p in pedidos_grupo],
            'camiones': []
        }
    
    # 3) Preparar datos para el solver
    datos = preparar_datos_solver(pedidos_validos, capacidad)
    pedidos_ids = list(datos.keys())
    
    # 4) Estimar número de camiones con heurística (+ margen)
    n_cam_heur = heuristica_ffd_pedidos(pedidos_validos, capacidad)
    n_cam = min(len(pedidos_validos), n_cam_heur + 5)
    
    # 5) Construir modelo CP-SAT
    model = cp_model.CpModel()
    
    # Variables x[(pedido_id, camion_idx)]
    x = {}
    for pid in pedidos_ids:
        for j in range(n_cam):
            x[(pid, j)] = model.NewBoolVar(f"x_bin_{pid}_{j}")
    
    # Variables y[camion_idx] (camión usado)
    y = {j: model.NewBoolVar(f"y_bin_{j}") for j in range(n_cam)}
    
    # 6) Restricciones básicas
    
    # Cada pedido EXACTAMENTE en un camión (obligatorio en binpacking)
    for pid in pedidos_ids:
        model.Add(sum(x[(pid, j)] for j in range(n_cam)) == 1)
    
    # Activar camión solo si tiene pedidos
    for pid in pedidos_ids:
        for j in range(n_cam):
            model.Add(x[(pid, j)] <= y[j])
    
    # Al menos un pedido por camión activo
    for j in range(n_cam):
        model.Add(sum(x[(pid, j)] for pid in pedidos_ids) >= y[j])
    
    # Monotonía: camiones se usan en orden
    for j in range(1, n_cam):
        model.Add(y[j] <= y[j - 1])
    
    # 7) Restricciones de capacidad
    max_positions = capacidad.max_positions
    max_pallets = capacidad.max_pallets
    levels = capacidad.levels
    
    for j in range(n_cam):
        # Peso y volumen (valores reales, no VCU)
        suma_peso = sum(
            int(round(datos[pid]['peso'])) * x[(pid, j)] 
            for pid in pedidos_ids
        )
        suma_vol = sum(
            int(round(datos[pid]['volumen'])) * x[(pid, j)] 
            for pid in pedidos_ids
        )
        
        model.Add(suma_peso <= int(capacidad.cap_weight) * y[j])
        model.Add(suma_vol <= int(capacidad.cap_volume) * y[j])
        
        # Pallets
        pallets_total = sum(
            datos[pid]['pallets_cap_int'] * x[(pid, j)] 
            for pid in pedidos_ids
        )
        model.Add(pallets_total <= max_pallets * SCALE_PALLETS * y[j])
        
        # Número máximo de órdenes (Walmart)
        if client_config.__name__ == 'WalmartConfig':
            if grupo_cfg.tipo == TipoRuta.MULTI_CD:
                # Máximo 10 por CD, 20 total
                cds_en_grupo = {datos[pid]['cd'] for pid in pedidos_ids}
                for cd in cds_en_grupo:
                    pedidos_cd = [pid for pid in pedidos_ids if datos[pid]['cd'] == cd]
                    if pedidos_cd:
                        model.Add(sum(x[(pid, j)] for pid in pedidos_cd) <= 10 * y[j])
                model.Add(sum(x[(pid, j)] for pid in pedidos_ids) <= 20 * y[j])
            else:
                max_ordenes = getattr(client_config, 'MAX_ORDENES', 10)
                model.Add(sum(x[(pid, j)] for pid in pedidos_ids) <= max_ordenes * y[j])
        
        # === RESTRICCIONES DE APILABILIDAD ===
        _agregar_restricciones_apilabilidad(
            model, x, datos, pedidos_ids, j, y[j], 
            max_positions, levels, SCALE_PALLETS
        )
    
    # 8) Agrupación por PO (si aplica)
    if client_config.AGRUPAR_POR_PO:
        _agregar_restricciones_agrupacion_por_po_v2(
            model, x, datos, pedidos_ids, n_cam
        )
    
    # 9) Función objetivo: MINIMIZAR número de camiones
    model.Minimize(sum(y[j] for j in range(n_cam)))
    
    # 10) Resolver
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = float(tiempo_max_seg)
    solver.parameters.num_search_workers = 1

    solver.parameters.log_search_progress = False  # No loggear (ahorra tiempo)
    solver.parameters.cp_model_presolve = True     # Simplificar modelo antes de resolver
    solver.parameters.linearization_level = 2      # Máxima linearización
    solver.parameters.symmetry_level = 2           # Detectar simetrías
    
    t0 = time.time()
    resultado = solver.Solve(model)
    t1 = time.time()
    
    status_map = {
        cp_model.OPTIMAL: StatusOptimizacion.OPTIMAL,
        cp_model.FEASIBLE: StatusOptimizacion.FEASIBLE
    }
    estado = status_map.get(resultado, StatusOptimizacion.NO_SOLUTION)
    
    print(f"[TIMING] CP-SAT (Bin) grupo {grupo_cfg.id}: {t1 - t0:.3f}s, estado: {estado.value}")
    
    # 11) Reconstruir solución
    if estado == StatusOptimizacion.NO_SOLUTION:
        return {
            'status': estado.value,
            'pedidos_asignados_ids': [],
            'pedidos_asignados': [],
            'pedidos_excluidos': [p.to_api_dict(capacidad) for p in pedidos_validos],
            'camiones': []
        }
    
    camiones: List[Camion] = []
    pedidos_asignados_ids = []
    
    for j in range(n_cam):
        if solver.Value(y[j]) < 1:
            continue
        
        # Pedidos asignados a este camión
        pids_camion = [pid for pid in pedidos_ids if solver.Value(x[(pid, j)]) == 1]
        
        if not pids_camion:
            continue
        
        pedidos_asignados_ids.extend(pids_camion)
        
        # Reconstruir camión
        camion = reconstruir_camion_desde_solver(
            pids_camion, datos, grupo_cfg, capacidad, len(camiones) + 1
        )
        
        # Calcular posiciones de apilabilidad
        pos_total = calcular_posiciones_apilabilidad(camion.pedidos, max_positions)
        camion.pos_total = pos_total
        
        camiones.append(camion)
    
    # En binpacking, todos los pedidos se asignan (o falla el modelo)
    pedidos_excluidos = [
        p for p in pedidos_validos 
        if p.pedido not in pedidos_asignados_ids
    ]
    
    return {
        'status': estado.value,
        'pedidos_asignados_ids': pedidos_asignados_ids,
        'pedidos_asignados': [
            p.to_api_dict(capacidad) 
            for c in camiones 
            for p in c.pedidos
        ],
        'pedidos_excluidos': [p.to_api_dict(capacidad) for p in pedidos_excluidos],
        'camiones': [c.to_api_dict() for c in camiones]
    }

def agregar_restricciones_agrupacion_por_po(model, x, pedidos, po_map, n_cam):
    po_grupos = {}
    for i in pedidos:
        po = po_map[i]
        po_grupos.setdefault(po, []).append(i)
 
    for po, items in po_grupos.items():
        if len(items) <= 1:
            continue
        for j in range(n_cam):
            for idx in range(1, len(items)):
                i1, i2 = items[0], items[idx]
                if (i1, j) in x and (i2, j) in x:
                    model.Add(x[(i1, j)] == x[(i2, j)])


# services/optimizer.py (agregar al inicio)
import time

def _log_timing(label: str, start: float):
    """Helper para medir tiempos"""
    elapsed = time.time() - start
    print(f"[TIMING] {label}: {elapsed:.3f}s")